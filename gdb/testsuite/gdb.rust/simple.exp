# Copyright (C) 2016 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Test expression parsing and evaluation that requires Rust compiler.

load_lib rust-support.exp
if {[skip_rust_tests]} {
    continue
}

standard_testfile .rs
if {[prepare_for_testing ${testfile}.exp $testfile $srcfile {debug rust}]} {
    return -1
}

set line [gdb_get_line_number "set breakpoint here"]
if {![runto ${srcfile}:$line]} {
    untested $testfile
    return -1
}

gdb_test "print a" " = \\(\\)"
gdb_test "ptype a" " = \\(\\)"

gdb_test "print b" " = \\\[\\\]"
gdb_test "ptype b" " = \\\[i32; 0\\\]"

gdb_test "print c" " = 99"
gdb_test "ptype c" " = i32"

gdb_test "print j" " = simple::Unit \\{\\}"
gdb_test_sequence "ptype j" "" {
    " = struct simple::Unit \\{"
    "\\}"
}
gdb_test "print simple::Unit" " = simple::Unit \\{\\}"

gdb_test "print g" " = \\(u8 \\(\\*\\)\\\[6\\\]\\) $hex b\"hi bob\""
gdb_test "ptype g" " = u8 \\(\\*\\)\\\[6\\\]"

gdb_test "print v" " = simple::Something::Three"
gdb_test_sequence "ptype v" "" {
    " = enum simple::Something \\{"
    "  One,"
    "  Two,"
    "  Three,"
    "\\}"
}

gdb_test "print w" " = \\\[1, 2, 3, 4\\\]"
gdb_test "ptype w" " = \\\[i32; 4\\\]"
gdb_test "print w\[2\]" " = 3"
gdb_test "print fromslice" " = 3"
gdb_test "print slice\[0\]" " = 3"

gdb_test "print y" " = simple::HiBob \\{field1: 7, field2: 8\\}"
gdb_test_sequence "ptype y" "" {
    " = struct simple::HiBob \\{"
    "  field1: i32,"
    "  field2: u64,"
    "\\}"
}
gdb_test "print y.field2" " = 8"

gdb_test "print z" " = simple::ByeBob \\(7, 8\\)"
gdb_test_sequence "ptype z" "" {
    " = struct simple::ByeBob \\("
    "  i32,"
    "  u64,"
    "\\)"
}
gdb_test "print z.1" " = 8"

gdb_test "print simple::ByeBob(0xff, 5)" \
    " = simple::ByeBob \\(255, 5\\)"

gdb_test "print diff2(3, 7)" " = -4"
gdb_test "print self::diff2(8, 9)" " = -1"
gdb_test "print ::diff2(23, -23)" " = 46"

# FIXME we need the ".*" because currently we don't extract the length
# and use it to intelligently print the string data.
gdb_test "print \"hello rust\"" \
    " = &str \\{data_ptr: $hex \"hello rust.*\", length: 10\\}"

gdb_test "print 0..5" " = .*::ops::Range.* \\{start: 0, end: 5\\}"
gdb_test "print ..5" " = .*::ops::RangeTo.* \\{end: 5\\}"
gdb_test "print 5.." " = .*::ops::RangeFrom.* \\{start: 5\\}"
gdb_test "print .." " = .*::ops::RangeFull \\{\\}"


proc test_one_slice {svar length base range} {
    global hex

    set result " = &\\\[.*\\\] \\{data_ptr: $hex, length: $length\\}"

    gdb_test "print $svar" $result
    gdb_test "print &${base}\[${range}\]" $result
}

test_one_slice slice 1 w 2..3
test_one_slice slice2 1 slice 0..1

test_one_slice all1 4 w ..
test_one_slice all2 1 slice ..

test_one_slice from1 3 w 1..
test_one_slice from2 0 slice 1..

test_one_slice to1 3 w ..3
test_one_slice to2 1 slice ..1


gdb_test_sequence "complete print y.f" "" \
    {"print y.field1" "print y.field2"}
gdb_test_sequence "complete print y." "" \
    {"print y.field1" "print y.field2"}
